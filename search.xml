<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Paper-Dijkstra1975-Guarded-Commands]]></title>
    <url>%2F2019-04-22%2FPaper-Dijkstra1975-Guarded-Commands%2F</url>
    <content type="text"><![CDATA[Guarded Commands, Nondeterminacy and Formal Derivation of Programsby Dijkstra / 1975 dl: Dijkstra1975 Dijkstra 介绍了一种构建程序的方式，即 “guarded commands”，利用它我们可以描述 nondeterminstic 程序。define nondeterminism: 程序执行过程中行为、甚至程序的终结态，都无法根据程序的初始状态唯一确定。 文章主体分三部分： guarded commands 表达体系，一种直观性的介绍 alternative construct 和 repetitive construct 正式的定义 guarded commands 体系下的程序推演：呈现为一种规则世界，而不是一个算法 关于 guarded commands 直观表达，因为原文实在惊艳，我决定把这段定义摘抄一下： 1234567&lt;guarded command&gt; ::= &lt;guard&gt; -&gt; &lt;guared list&gt;&lt;guard&gt; ::= &lt;boolean expression&gt;&lt;guarded list&gt; ::= &lt;statement&gt; &#123;; &lt;statement&gt;&#125;&lt;statement&gt; ::= &lt;alternative construct&gt; | &lt;repetitive construct&gt; | &quot;other statements&quot;&lt;alternative construct&gt; ::= if &lt;guarded command set&gt; fi&lt;repetitive construct&gt; ::= do &lt;guarded command set&gt; od&lt;guarded command set&gt; ::= &lt;guarded command&gt; &#123;[] &lt;guarded command&gt;&#125; Formal Definition of the Semantics 用离散数学替换了一下 if fi &amp; do od 的表达 weakest pre-conditions 的推演规则 感受：枚举大法好；递归大法好。 注意 Dijkstra 提了几个概念： [pre | post] conditions predicate transformer, weakest pre-conditions wp 其实最后的 Concluding Remarks 是我觉得最值得读的部分，也是最有趣的，我在深夜反复读这几段，感觉非常愉悦。摘录如下： The resarch, the outcome of which is reported in this article, was triggered by the observation that Euclid’s Algorithm could also be regarded as synchronizing the two cyclic processes do x:=x-y od and do y:=y-x od in such a way that the relation x&gt;0 and y&gt;0 would be kept invariantly true. It was only after this observation that we saw that the formal techniques we had already developed for the derivation of the synchronizing conditions that ensure the harmonious cooperation of (cyclic) sequential processes, such as can be identified in the total activity of operating systems, could be transferred lock, stock, and barrel to the development of sequential programs as shown in this article. The main difference is that while for sequential programs the situation “all guards false” is a desirable goal - for it means termination of a repetitive construct - one tries to avoid it in operating systems - for there it means deadlock. 神奇的是，在不同的方向上越走越深的时候，经常竟发现其中贯通之处。我其实更倾向将它归结于人的思考方式本身。关于他说的 programming langugage 和 operating systems 中的共同之处，我还希望更深入地进行思考。 The second reason to pursue these investigations was my personal desire to get a better appreciation, which part of the programming activity can be reguarded as a formal routine and which part of it seems to require “invention”. While the design of an alternative construct now seems to be a reasonably straightforward activity, that of a repetitive construct requires what I regard as “the invention” of an invariant relation and a variant function. My presentation of this calculus should, however, not be interpreted as my suggestion that all programs should be developed in this way: it just gives us another handle. 个人经历中，programming 经常是肌肉活动，但时不时冒出的 “invention”，还有灵光的时刻，实在是让人兴奋和满足。 The calculus does, however, explain my preference for the axiomatic definition of programming language semantics via predicate transformers above other definition techniques: the definition via predicate transformers seems to lend itself most readily to being forged into a tool for the goal-directed activity of program composition. 表达方式真的会影响很多。我经常会想某种语言选择了某种表达方式，设计者真正想做的是什么。在我从 Java 转向 Golang 后关于这方面的思考愈发多了。关于这一段所说的，我还不太有切身体会，希望进一步学习。 Finally, I would like to add a word or two about the potential nondeterminacy. Having worked mainly with hardly self-checking hardware, with which nonreproducing behavior of user programs is a very strong indication of a machine malfunctioning, I had to overcome a considerable mental resistance before I found myself willing to consider nondeterministic programs seriously. It is, however, fair to say that I could nver have discovered the calculus before having taken that hurdle: the simplicity and elegance of the above would have been destroyed by requiring the derivation of deterministic programs only. Whether nondeterminacy is eventually removed mechanically - in order not to mislead the maintenance engineer - or (perhaps only partly) by the programmer himself because, at second thought, he does care - e.g. for reasons of efficiency - which alternative is chosen is something I leave entirely to the circumstance. In any case we appreciate the nondeterministic program as a help stepping stone. 👆读这段超想笑，真的笑了。还是向他学习。 我将进一步思考的问题： 这篇文章是在什么背景下产生的，它的动机是什么 对比 Hoare 的 An axiomatic basis for computer programming 和 communicating Sequential Processes programming language &amp; operating systems invention in programming activity axiomatic definition of programming language semantics via predicate transformers]]></content>
      <categories>
        <category>cs</category>
      </categories>
      <tags>
        <tag>Dijkstra</tag>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK-java.lang.Integer]]></title>
    <url>%2F2017-07-12%2FJDK-java-lang-Integer%2F</url>
    <content type="text"><![CDATA[Integer 里有点意思的地方 生成一个实例#123public final class Integer extends Number implements Comparable&lt;Integer&gt; &#123; private final int value; // 核心&#125; 包装的 value 是 final field。如果顺序执行 Integer haha = new Integer(1000);, haha = 8;, haha = 30000;，会发生什么： 1234567891011121314/* * 新建 haha，它指向一个新实例，value = 1000； */Integer haha = new Integer(1000);/* * 自动装箱，意义等同于 haha = Integer.valueOf(8)，haha 指向另外的值为 8 的实例。 * 8 在 IntegerCache 范围之内，haha 指向的是缓存池中早就生成好的一个实例； * 上一步的实例等 GC 到了会被回收 */ haha = 8; /* * 一般情况下 30000 不在 IntegerCache 范围内，所以最终是 new Integer(30000) 生成的实例 */haha = 30000; new Integer() &amp; Integer.valueOf()#Integer i = 1000; 时自动装箱，其实是 Integer i = Integer.valueOf(1000); 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 所以很明显了，new Integer() 每次都新建一个实例，Integer.valueOf() 对于 IntegerCache 中已经缓存过的取值，会返回缓存池里的实例。 看一下IntegerCache 是什么： IntegerCache#12345678910111213141516171819202122232425262728293031323334private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; // 连续的整数，最高为 high，最低为 low private IntegerCache() &#123;&#125; static &#123; int h = 127; // high value may be configured by property /* 判断 high 的取值，默认127，最低127，可以被自定义 */ String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch (NumberFormatException nfe) &#123; // ignore &#125; &#125; /* 判断 high 的取值结束 */ high = h; caceh = new Integer[(high - low) + 1]; int j = low; for (int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) // 规定了 high 最小为 127 assert IntegerCache.high &gt;= 127; &#125;&#125; 所以 IntegerCache 是 Integer 的私有内部静态类，编译之后是 Integer$IntegerCache.class。它的类变量，cache[] 存储了一些 Integer 的实例，high 和 low 用来确定哪个取值范围内的 Integer 会被存储到 cache[] 中去。在 IntegerCache 这个类被加载的时候，会执行静态初始化代码块，这个里面会确定 high 的取值，它是允许自定义的，并按照 [low, high] 这个范围设置 cache[] 的大小并缓存连续的取值。 构造方法私有化#因为我们只会静态访问这个类，并不需要 IntegerCache 的实例，只需要类这个 class 对象。 整数类才有的套路#类似的，还有 ByteCache, ShortCache, LongCache，分别是 Byte, Short, Long 的私有内部静态类，不过它们的缓存范围是固定为 [-127, 128] 的，不像 Integer 可以设置 high 的取值。对于浮点类 Float 和 Double，它们在自动装箱或者使用 valueOf() 时都是新建一个实例，也没有所谓的 FloatCache 或者 DoubleCache。对于 Boolean 这个逻辑类型，非常简单的 true or false，没有必要使用内部类，也没有必要使用数组，而是简单的：1234public final class Boolean &#123; public static final Boolean TRUE = new Boolean(true); public static final Boolean FALSE = new Boolean(false);&#125;]]></content>
      <categories>
        <category>cs</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
</search>